#!/usr/bin/env python3
"""
Hard FIM programming test: implement a safe arithmetic expression evaluator.

The model's task is to implement eval_expr() and any helpers inside the
GENERATED CODE region so that this module passes the tests in the
__main__ block below.

Requirements for eval_expr(expr: str) -> float:

Grammar (fully supported):

    expr   := term (("+" | "-") term)*
    term   := factor (("*" | "/") factor)*
    factor := NUMBER | "(" expr ")" | ("+" | "-") factor

Where:

- NUMBER is a decimal literal like "3", "-2.5", or "0.01".
- Whitespace may appear anywhere and must be ignored.
- Unary + and unary - are supported (e.g., "-3", "+(1+2)", "--4").
- Operator precedence and associativity must match the grammar:
    * and / bind tighter than + and -
    All operators are left-associative.

Error handling:

- Raise ParseError on malformed input (unexpected characters, bad syntax,
  unmatched parentheses, empty expression, etc.).
- Raise ZeroDivisionError on division by zero.
- Do NOT use eval(), exec(), ast.parse(), ast.literal_eval(), or any
  third-party parsing libraries.

Implementation guidance (not mandatory but strongly suggested):

- Implement a small _Parser class that:
    - Stores the input string and a current index.
    - Has methods like parse_expr(), parse_term(), parse_factor().
    - Has helpers like peek(), consume(), expect(), and so on.
- eval_expr() should just construct the parser, call a top-level parse
  method, and ensure there is no trailing junk (i.e., EOF check).
"""

class ParseError(ValueError):
    """Raised when the expression cannot be parsed."""
    pass

# BEGIN GENERATED CODE

[[[1000;temp("0.7");top_p("0.9")]]]

# END GENERATED CODE

if __name__ == "__main__":
    # basic sanity tests; this is *not* exhaustive
    cases = {
        "1+2*3": 7.0,
        " (1 + 2) * 3 ": 9.0,
        "-2 * (3 + 5)": -16.0,
        "4/2/2": 1.0,
        "3 + 4 * 2 / (1 - 5)": 1.0,
        "--3": 3.0,
        "-(1+2)": -3.0,
        "1.5 * 2": 3.0,
    }
    for src, expected in cases.items():
        result = eval_expr(src)
        assert abs(result - expected) < 1e-9, (src, result, expected)

    # error cases: each should raise *something* specific
    for bad in ["", "()", "1+", "2**3", "3 + (4", "abc"]:
        try:
            r = eval_expr(bad)
        except ParseError:
            pass
        else:
            raise AssertionError(f"{bad!r} should have raised ParseError, got {r!r}")

    # division by zero case: must be ZeroDivisionError, not ParseError
    try:
        eval_expr("1/0")
    except ZeroDivisionError:
        pass
    else:
        raise AssertionError("1/0 should raise ZeroDivisionError")

    print("All tests passed.")

